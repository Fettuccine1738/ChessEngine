package com.github.fehinti.piece;

import com.github.fehinti.board.FENParser;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toList;
import static org.junit.jupiter.api.Assertions.*;

class PieceMoveTest {

    // * wrap fen string and stockfish's result of this moves
    record MoveList(String fen, List<String> moves) {
        public String getFen() {
            return fen;
        }
        public List<String> getMoves() {
            return moves;
        }
    }

    // use engine to get the node count at depth 1 and
    // compare with how moves count generated by pseudo legal
    private final static String ENGINE = "stockfish";

    @BeforeAll
    static synchronized void beforeAll() {
        Process process = null;
        BufferedReader reader = null;
        BufferedWriter writer = null;

        try  {
            ProcessBuilder processBuilder = new ProcessBuilder(ENGINE);
            processBuilder.directory(new File(System.getProperty("user.dir"))); // use pwd
            File err = new File("src/test/java/com/github/fehinti/piece/std.err");
            File out = new File("src/test/java/com/github/fehinti/piece/std.out");
            //processBuilder.redirectErrorStream(true);
            //processBuilder.redirectError(ProcessBuilder.Redirect.appendTo(err));
            //processBuilder.redirectOutput(ProcessBuilder.Redirect.appendTo(out));
            //processBuilder.inheritIO();
            process = processBuilder.start();

            writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            // send commands to stockfish
            writer.flush();
            writer.write("position startpos ");
            writer.newLine();
            writer.write("go perft 1");
            writer.newLine();
            writer.flush();

            List<String> results = readOutputWithTimeout(process.inputReader(), 5000L);

            boolean done = process.waitFor(10, TimeUnit.SECONDS);
            if (!done) {
                System.out.println("process timed out");
                process.destroyForcibly();
            }
            int exitcode = process.exitValue();
            assertTrue(done);
            assertFalse(results.isEmpty());
            assertEquals(0, exitcode);
            // * NOTE: process.waitFor is not called until the output has
            // * been read because the output buffer might stall the
            // * process
    } catch (IOException | InterruptedException ioe) {
            System.out.println(ioe.getMessage());
    } finally {
            try {
                if (reader != null) reader.close();
                if (writer != null) writer.close();
                if (process != null && process.isAlive()) process.destroyForcibly();
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }
    }

    private static synchronized List<String> readOutput(InputStream inputStream) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
           return reader.lines().collect(toList());
        }
    }

    private static synchronized List<String> readOutputWithTimeout(BufferedReader reader, long millisec) throws IOException {
        List<String> results = new ArrayList<>();
        long start = System.currentTimeMillis();

        try {
            String line;
            while ((line = reader.readLine()) != null) {
                results.add(line);
                if (System.currentTimeMillis() > start + millisec) {
                    System.out.println("Read timed out");
                    break;
                }
                // stockfish end of perft results
                if (line.contains("Nodes searched: ") || line.trim().matches("\\d+")) break;
            }
        } catch (IOException ioe) {
            if (!ioe.getMessage().contains("Stream closed")) throw ioe;
            System.out.println(ioe.getMessage());
        }
        return results;
    }
    //private static Process startEngineWithCommands(List<String> commands) throws IOException {
       //ProcessBuilder processBuilder = new ProcessBuilder(ENGINE);
       //processBuilder.directory(new File(System.getProperty("user.dir")));
       //Process process = processBuilder.start();
//
       //try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream())) {
           //for (String cmd : commands) {
               //bw.write(cmd);
               //bw.newLine();
               //bw.flush();
           //}
       //};
       //return process;
    //}

    private static Stream<MoveList> getsPerftResultFromStockfish() {
        List<MoveList> lines = new ArrayList<>();

        try (BufferedReader br = Files.newBufferedReader(Paths.get("C:\\Users\\favya\\IdeaProjects\\ChessEngine\\src\\test\\java\\com\\github\\fehinti\\piece\\fenway.txt"))) {
           br.lines().forEach(line -> {
               try {
                   ProcessBuilder pb = new ProcessBuilder(ENGINE);
                   pb.redirectError(new File("src/test/java/com/github/fehinti/piece/std.err"));
                   pb.redirectOutput(new File("src/test/java/com/github/fehinti/piece/std.out"));
                   pb.inheritIO();
                   Process process = pb.start();
                   BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

                   writer.write("position fen " + line);
                   writer.newLine();
                   writer.write("go perft 1");
                   writer.flush();

                   AtomicReference<List<String>> list = new AtomicReference<>(new ArrayList<>());
                   list.set(readOutput(process.getInputStream()));

                   // clean up the strings from g1e2: 1 to g1e2
                   MoveList m = new MoveList(line, cleanup(list.get()));
                   lines.add(m);

                   writer.write("quit"); // end the process
                   int exitCode = process.waitFor();
                   assertEquals(0, exitCode);

               } catch (IOException | InterruptedException e) {
                   System.out.println(e.getMessage());
               }
           });
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return lines.stream();
    }

    // * first four lines of stockfish's output are process id, and n
    // * info string Available processors: 0-3
    // * info string Using 1 thread
    // * info string NNUE evaluation using nn-1111cefa1111.nnue (133MiB, (22528, 3072, 15, 32, 1))
    // * info string NNUE evaluation using nn-37f18f62d772.nnue (6MiB, (22528, 128, 15, 32, 1))
    private static List<String> cleanup(List<String> lines) {
        return lines.stream().skip(4)
                .map(e -> {
                   String[] res = e.split(":");
                   res[0] = res[0].trim();
                   return res[0];
                })
                .collect(toList());
    }

    @BeforeEach
    void setUp() {
    }

    @AfterEach
    void tearDown() {
    }

    /**
     * Uses Stockfish's "go perft 1" to generate all legal moves for the given FEN
     * and compares them with our pseudo-legal move generator.
     */
    @ParameterizedTest
    @MethodSource("getsPerftResultFromStockfish")
    void testsMoveListAgainstStockFishResult(MoveList movelist) {
        Board b = FENParser.parseFENotation(movelist.getFen());
        List<Integer> pseudoMoves = generatePseudoLegal(b);
        List<Integer> legalmoves = generateLegalMoves(b, pseudoMoves);


        assertEquals(movelist.getMoves().size(), legalmoves.size(), "Move count mismatch");

        legalmoves.stream()
                .map(Move::printMove)
                .forEach(s -> assertTrue(movelist.getMoves().contains(s)));
    }
}